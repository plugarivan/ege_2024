'''
На складе требуется разместить N контейнеров различного размера, каждый из которых имеет форму куба. Контейнеры имеют разные цвета, которые обозначаются латинскими буквами. Чтобы сэкономить место, контейнеры вкладывают друг в друга. Один контейнер можно вложить в другой, если а) размер стороны внешнего контейнера превышает размер стороны внутреннего на K и более условных единиц и б) цвета внешнего и внутреннего контейнеров различны. Группу вложенных друг в друга контейнеров называют блоком. Количество контейнеров в блоке может быть любым. Каждый блок, независимо от количества и размера входящих в него контейнеров, а также каждый одиночный контейнер, не входящий в блоки, занимает при хранении одну складскую ячейку.
Определите минимальное количество ячеек, которые потребуются для хранения всех контейнеров, и максимальное количество контейнеров в одном блоке.
Входные данные представлены в файле 26-102.txt следующим образом. В первой строке входного файла записано число N – количество контейнеров (натуральное число, не превышающее 20 000) и число K (1 ≤ K ≤ 1000) – наименьшая допустимая разница размеров вложенных соседних контейнеров. Каждая из следующих N строк содержит натуральное число, не превышающее 10000 – длину стороны очередного контейнера, и латинскую букву, обозначающую цвет этого контейнера.
'''
with open('files/26-102.txt') as f:
    n, k = map(int, f.readline().split())
    data = []
    for x in f:
        size, color = x.split()
        data.append([int(size), color])
    data.sort(reverse=True)
count = 0 #количество ячеек
max_block = -1
flag = 0
#создаем блоки
while data: #пока есть контейнеры
    if flag == 0: #первый контейнер в блоке
        count_block = 0
        last_cont = [10 ** 10, '']
        count += 1
    flag = 0
    for i in range(len(data)):#заполняем блок контейнера и удаляем те, которые взяли
        if last_cont[0] - data[i][0] >= k and last_cont[1] != data[i][1]:
            last_cont = data[i]
            flag = 1
            count_block += 1
            max_block = max(max_block, count_block)
            del data[i]
            break
print(count, max_block)
